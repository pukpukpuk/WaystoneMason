<p align="center"><img src="Images/Cover.png" width="500" ></p>

[English documentation](README.md)

[**Waystone Mason**](#семантика-названия) — это библиотека для 2D поиска пути по навмешу.

Чем этот проект отличается от готовых решений?
 - Навмеши не являются синглтонами, что дает возможность выделять агентам персональные навмеши. 
 - Есть возможность ручного управления процессом обновления состояния препятствия на навмеше, 
что, например, можно использовать для эффекта памяти у агентов.

---

# Краткое описание работы

### Работа навмешей
Свободная для перемещения область размечена треугольниками — там, где нет никакого треугольника, ходить нельзя. 
Треугольники хранятся через spatial index, другими словами — группируются в чанки, то есть в квадратные 
области фиксированного размера, расположенные по сетке.

Соответственно, чанк создаётся автоматически только в случае, если в его пределах появится какое-либо препятствие.  
Поэтому желательно самостоятельно прегенерировать чанки в необходимых местах — 
либо вручную через метод `NavMesh.GetOrCreateChunk(Vector2Int)`, 
либо задать область прегенерации через [WMObstaclesHolder.PregeneratedEmptyChunksRegion](#WMObstaclesHolder).

### Работа поиска пути
Треугольники можно представить в виде графа, где вершины — это сами треугольники, а рёбра — наличие общей стороны 
между двумя треугольниками. Для поиска пути в таком графе используется алгоритм A*, который находит последовательность 
треугольников, через которые нужно пройти, чтобы достичь цели. Затем полученная последовательность обрабатывается 
с помощью алгоритма String Pulling, который формирует финальный маршрут агента.

# Документация

**Waystone Mason** предусматривает два уровня взаимодействия с системой навигации: 
[ручной](#ручное-управление) и [автоматический](#автоматическое—управление).

## Автоматическое управление

В проекте предусмотрено несколько компонентов для базовой инфраструктуры поиска пути.

### WMNavMeshHolder
При запуске игры создаёт экземпляр навмеша с заданным радиусом агента и периодически вызывает его перестройку.

Имеет событие `OnBeforeRebuild`, вызываемое перед каждой перестройкой. Пригодится при ручном сканировании препятствий. 

### WMAgent
Имеет метод для установки цели перемещения — `SetGoal(Vector2)`. 
При его вызове агент рассчитает путь до цели по навмешу указанного `WMNavMeshHolder` и начнет следовать по нему.

### WMDynamicObstacle
Исходя из указанного коллайдера строит контур препятствия. Сам по себе не влияет на навмеш — для этого необходимо
вызвать его метод `Affect(NavMesh)`, чтобы актуализировать состояние препятствия на указанном навмеше.

### WMObstaclesHolder
Контейнер для всех препятствий на сцене. Позволяет эффективно находить все препятствия в заданном радиусе.

Поле `PregeneratedEmptyChunksRegion` обозначает прямоугольную область, для которой в начале игры будут созданы пустые чанки.

**Его наличие обязательно для работы остальных компонентов.**

### WMNavMeshObstaclesScanner
Исходя из указанных условий ищет подходящие `WMDynamicObstacle` и вызывает их метод `Affect(NavMesh)` для указанного 
`WMNavMeshHolder`.

У препятствий, которые изменили свое состояние (например, переместились или изменили форму контура)
с момента последнего обновления, формально существуют два контура:
 - последний (тот, что был у препятствия во время последнего вызова Affect())
 - и актуальный (текущий, соответствующий его текущей форме или позиции).

Если в зону сканирования попадает только последний контур, сканер считает, что препятствие либо исчезло, либо переместилось,
и удалит его с навмеша. Если попадает актуальный контур, то сканер добавит его на навмеш и удалит последний.


## Ручное управление

Если возможностей встроенных компонентов не хватает и нужен более тонкий контроль над содержимым навмешей, 
то стоит спуститься на уровень ниже, на уровень ядра библиотеки.

Для создания навмеша необходимо указать лишь радиус коллайдера агента.
**Учтите, что радиус нельзя изменять после создания объекта.**
```cs
var agentRadius = 0.25f;
var navMesh = new NavMesh(agentRadius);
```

Для ручного добавления препятствия нужно передать в метод его контур объектом типа `Clipper.PathD`. 
Чтобы отобразить изменения добавленного контура, нужно удалить старый и добавить актуальный. 
```cs
var triangleObstacle = new PathD { new PointD(0, 0), new PointD(1, 0), new PointD(1, 1) };
navMesh.AddObstacle(triangleObstacle);
navMesh.Rebuild();

// Later
navMesh.RemoveObstacle(triangleObstacle);
var translated = Clipper.TranslatePaths(triangleObstacle, 1, 0);
navMesh.AddObstacle(translated);

navMesh.Rebuild();
```

Если препятствие по задумке не должно никак изменяться и пропадать, то можно добавить его на навмеш перманентно. 
Во время перестройки навмешей перманентные препятствия обрабатываются дешевле динамических, 
но их будет нельзя удалить с навмешей в дальнейшем.
```cs
navMesh.AddObstacle(triangleObstacle, true);
```

Перестройка NavMesh — **дорогая операция**, поэтому при добавлении или удалении препятствия NavMesh **не перестраивается автоматически**, 
для этого нужно вызывать метод `NavMesh.Rebuild()`.

Для получения пути нужно лишь указать точки начала и конца маршрута. Метод вернет `false`, если простроить маршрут невозможно
```cs
var start = new Vector2(0, 0);
var goal = new Vector2(2, 2);
if (!navMesh.TryComputePath(start, goal, out var path)) Debug.Log("Agent can't reach the goal!");
```


# Семантика названия
Waystone: Итоговый путь, по которому нужно следовать агенту, — это набор углов, то есть мест где нужно повернуть и продолжить 
движение по прямой, поэтому их и можно назвать путеводными камнями

Mason: Сама библиотека является *каменщиком*, ведь именно он создает путеводные камни для агентов